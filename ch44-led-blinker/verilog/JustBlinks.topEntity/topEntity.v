/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.9.0. DO NOT MODIFY.
*/
`default_nettype none
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input wire  clk // clock


      // Outputs
    , output wire  result
    );
  wire  c$bindCsr;
  // JustBlinks.hs:26:1-73
  wire [0:0] x;
  wire [3:0] c$case_alt;
  // JustBlinks.hs:26:1-73
  wire [2:0] x_0;
  wire [3:0] c$case_alt_0;
  wire [3:0] result_1;
  wire [0:0] c$app_arg;
  // JustBlinks.hs:37:15-17
  // This is the only register
  // the inverse of the left-most bit determines whether the LED is on or off
  reg [3:0] r = {1'b1,1'd0,2'bxx};

  // resetGen begin
  // pragma translate_off
  reg  rst;
  localparam reset_period = 1000000 - 10 + (1 * 100000);
  `ifndef VERILATOR
  initial begin
    #1 rst =  1 ;
    #reset_period rst =  0 ;
  end
  `else
  always begin
    // The redundant (rst | ~ rst) is needed to ensure that this is
    // calculated in every cycle by verilator. Without it, the reset will stop
    // being updated and will be stuck as asserted forever.
    rst = $c("this->reset_gen(",reset_period,",true)") & (rst | ~ rst);
  end
  `systemc_interface
  CData reset_gen(vluint32_t reset_period, bool active_high) {
    static vluint32_t to_wait = reset_period;
    static CData reset = active_high ? 1 : 0;
    static bool finished = false;

    if(!finished) {
      if(to_wait == 0) {
        reset = reset == 0 ? 1 : 0;
        finished = true;
      }
      else {
        to_wait = to_wait - 1;
      }
    }

    return reset;
  }
  `verilog
  `endif
  assign c$bindCsr = rst;
  // pragma translate_on
  // resetGen end

  // r itself
  // 1: 10xx
  // 2: 0000
  // 3: 0001

  assign x = r[2:2];

  // Are these two cases just incrementing different counters? one corresponding to 20 and the other to 50?

  // this is what gets done if r[3:3] is 0, ie if the LED is on
  // Big-endian 1'd1 is 1, this is the condition
  assign c$case_alt = (x == 1'd1) ? {1'b0,3'd0} : {1'b1,x + 1'd1,2'bxx};
  // Value               condition met (x == 1)
  // r: 0                false
  // 1: 1                true

  assign x_0 = r[2:0];
  // Value               condition met (x_0 == 100)
  // r: 0xx              false
  // 1: 000              false
  // 2: 000 + 001 = 001  false
  // 3: 001 + 001 = 010  false
  // 4: 010 + 001 = 011  false
  // 5: 011 + 001 = 100  true

  // this is what gets done if r[3:3] is 1, ie if the LED is off
  // Big-endian 3'd4 is 100, this is the condition
  // Note that r[2:0] is being read little-endian, and 3'd4 is big-endian, so
  assign c$case_alt_0 = (x_0 == 3'd4) ? {1'b1,1'd0,2'bxx} : {1'b0,x_0 + 3'd1};
  // 1: 0xxx -- Not used
  // 2: 0001
  // 3:

  // result_1 is the next value of r;
  // if the left-most bit of r is positive (it initially is) then pick case_alt
  // so we only switch LED state if case_alt itself produces gives 0 as its MSB
  assign result_1 = r[3:3] ? c$case_alt : c$case_alt_0;
  // 1: 11xx
  // 2: 0001

  // This is the actual LED state
  assign c$app_arg = r[3:3] ? 1'b0 : 1'b1;

  assign result = (c$app_arg);

  // register begin
  // c$bindCsr is reset
  always @(posedge clk or  posedge  c$bindCsr) begin : r_register
    if ( c$bindCsr) begin
      // if reset then reset the value of r
      r <= {1'b1,1'd0,2'bxx};
    end else begin
      r <= result_1;
    end
  end
  // register end


endmodule

